# 1.监听器概述  * 它是一个接口，内容由我们来实现 * 它需要注册，例如注册在按钮上    * 监听器中的方法，会在特殊事件发生时被调用# 2.典型的例子* 事件源----小偷   * 事件------偷东西   * 监听器----警察   * 监听器中的方法：抓捕   # 3.javaweb的三大组件 * Servlet   * Listener   * Filter  # 4.JavaWeb中的监听器事件源：三大域！   事件对象：```ServletContextEvent：ServletContext getServletContext()HttpSessionEvent：HttpSession getSession()ServletRequest：ServletContext getServletContext()；ServletReques getServletRequest()；ServletContextAttributeEvent：ServletContext getServletContext()；String getName()：获取属性名  Object getValue()：获取属性值  HttpSessionBindingEvent  ServletRequestAttributeEvent  ```注册，是在web.xml中配置来完成注册！```<listener><listener-class>cn.MyServletContextListener</listener-class></listener><listener><listener-class>cn.MyHttpSessionListener</listener-class></listener><listener><listener-class>cn.MyServletRequestListener</listener-class></listener><session-config> <session-timeout>1</session-timeout></session-config>```## 4.1ServletContext### 4.1.1生命周期监听ServletContextListener    它有两个方法，一个在出生时调用，一个在死亡时调用；  Tomcat启动和关闭时调用下面两个方法  ```// 创建Servletcontext时void contextInitialized(ServletContextEvent sce)// 销毁Servletcontext时void contextDestroyed(ServletContextEvent sce)``````java/* * ServletContextListener实现类 * contextDestroyed() -- 在ServletContext对象被销毁前调用 * contextInitialized() --  -- 在ServletContext对象被创建后调用 * ServletContextEvent -- 事件类对象 *     该类有getServletContext()，用来获取ServletContext对象，即获取事件源对象 */public class MyServletContextListener implements ServletContextListener {	public void contextDestroyed(ServletContextEvent evt) {		System.out.println("销毁ServletContext对象");	}	public void contextInitialized(ServletContextEvent evt) {		System.out.println("创建ServletContext对象");	}}```### 4.1.2属性监听  ServletContextAttributeListener    它有三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个是在移除属性时调用。```//添加属性时；void attributeAdded(ServletContextAttributeEvent event)//替换属性时；void attributeReplaced(ServletContextAttributeEvent event)//移除属性时；void attributeRemoved(ServletContextAttributeEvent event)//事件：ServletContextAttributeEventString getName()：获取当前操作的属性名；Object getValue()：获取当前操作的属性值；ServletContext getServletContext()：获取ServletContext对象。```## 4.2HttpSession### 4.2.1生命周期监听：HttpSessionListener   它有两个方法，一个在出生时调用，一个在死亡时调用  开始会话和结束会话时调用下面两个方法   ```//创建session时void sessionCreated(HttpSessionEvent se)//销毁session时void sessionDestroyed(HttpSessionEvent se)``````java/* * HttpSessionListener实现类 * sessionCreated() -- 在HttpSession对象被创建后被调用 * sessionDestroyed() --  -- 在HttpSession对象被销毁前调用 * HttpSessionEvent -- 事件类对象 *     该类有getSession()，用来获取当前HttpSession对象，即获取事件源对象 */public class MyHttpSessionListener implements HttpSessionListener {	public void sessionCreated(HttpSessionEvent evt) {		System.out.println("创建session对象");	}	public void sessionDestroyed(HttpSessionEvent evt) {		System.out.println("销毁session对象");	}}```### 4.2.2属性监听HttpSessioniAttributeListener  它有三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个是在移除属性时调用。```// 添加属性时；void attributeAdded(HttpSessionBindingEvent event)// 替换属性时void attributeReplaced(HttpSessionBindingEvent event)// 移除属性时void attributeRemoved(HttpSessionBindingEvent event)// 事件：HttpSessionBindingEventString getName()：获取当前操作的属性名；Object getValue()：获取当前操作的属性值；HttpSession getSession()：获取当前操作的session对象。```## 4.3ServletRequest### 4.3.1生命周期监听ServletRequestListener  它有两个方法，一个在出生时调用，一个在死亡时调用；```//创建request时void requestInitialized(ServletRequestEvent sre)//销毁request时void requestDestroyed(ServletRequestEvent sre)``````java/* * ServletRequestListener实现类 * requestDestroyed() -- 在ServletRequest对象被销毁前调用 * requestInitialized() -- 在ServletRequest对象被创建后调用 * ServletRequestEvent -- 事件类对象 *     该类有getServletContext()，用来获取ServletContext对象 *     该类有getServletRequest()，用来获取当前ServletRequest对象，即事件源对象 */public class MyServletRequestListener implements ServletRequestListener {	public void requestDestroyed(ServletRequestEvent evt) {		System.out.println("销毁request对象");	}	public void requestInitialized(ServletRequestEvent evt) {		System.out.println("创建request对象");	}}```### 4.3.2属性监听ServletRequestAttributeListener  它有三个方法，一个在添加属性时调用，一个在替换属性时调用，最后一个是在移除属性时调用。```//添加属性时void attributeAdded(ServletRequestAttributeEvent srae)//替换属性时void attributeReplaced(ServletRequestAttributeEvent srae)//移除属性时void attributeRemoved(ServletRequestAttributeEvent srae)// 事件：ServletRequestAttributeEventString getName()：获取当前操作的属性名；Object getValue()：获取当前操作的属性值；ServletContext getServletContext()：获取ServletContext对象；ServletRequest getServletRequest()：获取当前操作的ServletRequest对象。```# 5.感知监听（和HttpSession相关）两个与HttpSession相关的特殊的监听器，这两个监听器的特点如下：> 不用在web.xml文件中部署   > 这两个监听器不是给session添加，而是给Bean添加。即让Bean类实现监听器接口，然后再把Bean对象添加到session域中。下面对这两个监听器介绍一下## 5.1HttpSessionBindingListener当某个类实现了该接口后   可以感知本类对象添加到session中,以及感知从session中移除。    例如让Person类实现HttpSessionBindingListener接口，  那么当把Person对象添加到session中，   或者把Person对象从session中移除时会调用下面两个方法：```//当把监听器对象添加到session中会调用监听器对象的本方法public void valueBound(HttpSessionBindingEvent event)//当把监听器对象从session中移除时会调用监听器对象的本方法public void valueUnbound(HttpSessionBindingEvent event)```### 5.1.1开发步骤> 编写Person类，让其实现HttpSessionBindingListener监听器接口   > 编写Servlet类，一个方法向session中添加Person对象，另一个从session中移除Person对象    > 在index.jsp中给出两个超链接，分别访问Servlet中的两个方法  ## 5.2HttpSessionActivationListener### 5.2.1钝化  Tomcat会在session从时间不被使用时钝化session对象，  所谓钝化session，就是把session通过序列化的方式保存到硬盘文件中。当session被Tomcat钝化时，session中存储的对象也被纯化### 5.2.2活化当用户再使用session时，Tomcat还会把钝化的对象再活化session，  所谓活化就是把硬盘文件中的session在反序列化回内存。   当session被活化时，也会把session中存储的对象活化。   ### 5.2.3方法调用如果某个类实现了HttpSessionActiveationListener接口后，   当对象随着session被钝化和活化时，下面两个方法就会被调用：```// 当对象感知被活化时调用本方法public void sessionWillPassivate(HttpSessionEvent se)// 当对象感知被钝化时调用本方法public void sessionDidActivate(HttpSessionEvent se)```### 5.2.4说明HttpSessionActivationListener监听器与HttpSessionBindingListener监听器相似，都是感知型的监听器。    例如：   让Person类实现了HttpSessionActivationListener监听器接口，并把Person对象添加到了session中后，当Tomcat钝化session时，同时也会钝化session中的Person对象，这时Person对象就会感知到自己被钝化了，其实就是调用Person对象的sessionWillPassivate()方法。当用户再次使用session时，Tomcat会活化session，这时Person会感知到自己被活化，其实就是调用Person对象的sessionDidActivate()方法。      注意，因为钝化和活化session，其实就是使用序列化和反序列化技术把session从内存保存到硬盘，和把session从硬盘加载到内存。这说明如果Person类没有实现Serializable接口，那么当session钝化时就不会钝化Person，而是把Person从session中移除再钝化！这也说明session活化后，session中就不在有Person对象了。### 5.2.5开发步骤   * 第一步：   先来配置Tomcat钝化session的参数，把下面配置文件放到  tomcat\conf\catalina\localhost目录下！文件名称为项目名称。```xml<Context>	<Manager className="org.apache.catalina.session.PersistentManager" maxIdleSwap="1">		<Store className="org.apache.catalina.session.FileStore" directory="mysession"/>	</Manager></Context>```访问项目的index.jsp页面，这会使Tomcat创建Session对象，然后等待一分钟后，查看    Tomcat\work\Catalina\localhost\listener\mysession   目录下是否会产生文件，如果产生了，说明钝化session的配置成功了，  可以开始下一步了。* 第二步：  创建Person类，让Person类实现HttpSessionActivationListener和Serializable接口  后者是为了实现序列化才实现的* 第三第四步：  就是简单的写 Servlet 往 session 里面添加对象和移除对象编写 index.jsp 用来提交请求（添加和移除 person 对象）   * 最后一步：   演示效果打开index.jsp页面，这时Tomcat会创建session，必须在1分钟之前点击addPerson链接，这能保证在session被钝化之前把Person对象添加到session中；   等待一分钟，这时session会被钝化，也就会调用Person的sessionWillPassivate()；   刷新一下index.jsp页面，这会使session活化，会调用Person的sessionDidActivate()方法。   